name: CI/CD for LoginApi to Windows EC2

on:
  push:
    branches: [ main ]

jobs:
  deploy-loginapi-windows:
    runs-on: windows-latest

    env:
      EC2_HOST_WINDOWS: ${{ vars.EC2_HOST_WINDOWS }}
      EC2_ADMIN_PASSWORD: ${{ secrets.EC2_ADMIN_PASSWORD }}
      GH_TOKEN: ${{ secrets.GH_TOKEN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Build and Publish Artifact
        shell: pwsh
        run: |
          dotnet restore LoginApi.csproj
          dotnet publish LoginApi.csproj -c Release -o ./publish

      - name: Upload publish directory as artifact
        uses: actions/upload-artifact@v4
        with:
          name: loginapi-publish
          path: ./publish
          retention-days: 1

      - name: Install Posh-SSH Module
        shell: pwsh
        run: |
          Install-Module -Name Posh-SSH -Force -Scope CurrentUser

      - name: Deploy and Configure EC2
        shell: pwsh
        run: |
          $remoteHost = $env:EC2_HOST_WINDOWS
          if (-not $remoteHost) { throw "‚ùå EC2_HOST_WINDOWS is not set." }

          $username = "Administrator"
          $password = $env:EC2_ADMIN_PASSWORD
          $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($username, $securePassword)

          Write-Host "üîê Connecting to EC2 at $remoteHost..."
          $session = New-SSHSession -HostName $remoteHost -Credential $credential -AcceptKey -ConnectionTimeout 30000 -ErrorAction Stop

          $deployPath = "C:\inetpub\wwwroot\LoginApi"
          $artifactPath = "C:\Users\Administrator\Artifacts"
          $artifactZip = "$artifactPath\loginapi.zip"
          $tempExtract = "C:\Temp\LoginApiExtract"
          $appPool = "LoginApiAppPool"
          $GhToken = $env:GH_TOKEN
          $RepoOwner = "${{ github.repository_owner }}"
          $RepoName = "${{ github.event.repository.name }}"
          $RunId = "${{ github.run_id }}"
          $ArtifactName = "loginapi-publish"

          $finalCommand = @"
          try {
              # IIS Setup
              Install-WindowsFeature -Name Web-Server -IncludeManagementTools

              # .NET 8.0 Installation
              Write-Host "üì¶ Installing .NET 8.0..."
              \$runtimeUrl = "https://download.visualstudio.microsoft.com/download/pr/7f8f3c3a-9f3a-4f9e-9f6e-3e9f3c3a9f3a/7f8f3c3a9f3a4f9e9f6e3e9f3c3a9f3a/dotnet-runtime-8.0.0-win-x64.exe"
              \$sdkUrl = "https://download.visualstudio.microsoft.com/download/pr/8f9e3c3a-7f8f-4f9e-9f6e-3e9f3c3a9f3a/8f9e3c3a7f8f4f9e9f6e3e9f3c3a9f3a/dotnet-sdk-8.0.100-win-x64.exe"
              \$runtimeInstaller = "C:\Temp\dotnet-runtime.exe"
              \$sdkInstaller = "C:\Temp\dotnet-sdk.exe"
              Invoke-WebRequest -Uri \$runtimeUrl -OutFile \$runtimeInstaller
              Invoke-WebRequest -Uri \$sdkUrl -OutFile \$sdkInstaller
              Start-Process -FilePath \$runtimeInstaller -ArgumentList "/quiet" -Wait
              Start-Process -FilePath \$sdkInstaller -ArgumentList "/quiet" -Wait
              Write-Host "‚úÖ .NET installed."

              # PostgreSQL Installation
              Write-Host "üêò Installing PostgreSQL..."
              \$pgInstaller = "https://get.enterprisedb.com/postgresql/postgresql-15.5-1-windows-x64.exe"
              \$pgExe = "C:\Temp\pginstaller.exe"
              Invoke-WebRequest -Uri \$pgInstaller -OutFile \$pgExe
              Start-Process -FilePath \$pgExe -ArgumentList "--mode unattended --unattendedmodeui minimal --superpassword postgres123 --prefix C:\PostgreSQL" -Wait
              Write-Host "‚úÖ PostgreSQL installed."

              # Artifact Download
              \$URL = "https://api.github.com/repos/$RepoOwner/$RepoName/actions/runs/$RunId/artifacts"
              \$HEADERS = @{ Authorization = "token $GhToken"; Accept = "application/vnd.github.v3+json" }
              if (-not (Test-Path "$artifactPath")) { New-Item -ItemType Directory -Path "$artifactPath" -Force }
              \$RESPONSE = Invoke-RestMethod -Uri \$URL -Headers \$HEADERS
              \$ARTIFACT = \$RESPONSE.artifacts | Where-Object { \$_.name -eq "$ArtifactName" }
              if (-not \$ARTIFACT) { throw "Artifact not found." }
              \$DOWNLOAD_URL = \$ARTIFACT.archive_download_url
              Invoke-WebRequest -Uri \$DOWNLOAD_URL -Headers \$HEADERS -OutFile "$artifactZip"

              # Extract Artifact
              if (-not (Test-Path "$tempExtract")) { New-Item -ItemType Directory -Path "$tempExtract" -Force }
              Add-Type -AssemblyName System.IO.Compression.FileSystem
              [System.IO.Compression.ZipFile]::ExtractToDirectory("$artifactZip", "$tempExtract")

              # Deploy to IIS
              \$dllPath = Get-ChildItem -Path "$tempExtract" -Recurse -Filter "LoginApi.dll" | Select-Object -First 1
              if (\$dllPath) {
                  \$sourceFolder = \$dllPath.Directory.FullName
                  if (-not (Test-Path "$deployPath")) { New-Item -ItemType Directory -Path "$deployPath" -Force }
                  Get-ChildItem -Path "\$sourceFolder\*" -Force | Move-Item -Destination "$deployPath" -Force
              } else {
                  throw "LoginApi.dll not found."
              }

              Import-Module WebAdministration
              if (-not (Test-Path IIS:\AppPools\$appPool)) {
                  New-WebAppPool -Name "$appPool"
                  Set-ItemProperty IIS:\AppPools\$appPool -Name "managedRuntimeVersion" -Value ""
              }
              if (-not (Test-Path IIS:\Sites\Default Web Site\LoginApi)) {
                  New-WebApplication -Site "Default Web Site" -Name "LoginApi" -PhysicalPath "$deployPath" -ApplicationPool "$appPool"
              }
              Restart-WebAppPool -Name "$appPool"

              # Run Migration
              Push-Location "$deployPath"
              if (Test-Path "LoginApi.dll") {
                  dotnet LoginApi.dll migrate
                  Write-Host "‚úÖ Migration completed."
              } else {
                  Write-Host "‚ö†Ô∏è Migration skipped: LoginApi.dll missing."
              }
              Pop-Location
          } catch {
              Write-Host "‚ùå Deployment error: \$($_.Exception.Message)"
          }
          "@

          $response = Invoke-SSHCommand -SshSession $session -Command $finalCommand
          Write-Host "üîß Remote output:"
          $response.Output
          Write-Host "üîö Exit status: $($response.ExitStatus)"

          Remove-SSHSession -SshSession $session
